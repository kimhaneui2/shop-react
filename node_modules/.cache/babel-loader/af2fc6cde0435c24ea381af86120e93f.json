{"ast":null,"code":"var _objectWithoutProperties = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\n\nvar _toConsumableArray = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _get = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _objectSpread = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/kimhaneui/Documents/\\u1105\\u1175\\u110B\\u1162\\u11A8\\u1110\\u1173 \\u1111\\u1173\\u1105\\u1169\\u110C\\u1166\\u11A8\\u1110\\u1173/shop/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _excluded = [\"refetchPage\"],\n    _excluded2 = [\"pageParam\"],\n    _excluded3 = [\"pageParam\"];\n\n/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"react\"), require(\"use-sync-external-store/shim\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\", \"use-sync-external-store/shim\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).ReactQuery = {}, t.React, t.shim);\n}(this, function (t, e, s) {\n  \"use strict\";\n\n  function r(t) {\n    if (t && t.__esModule) return t;\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (s) {\n      if (\"default\" !== s) {\n        var r = Object.getOwnPropertyDescriptor(t, s);\n        Object.defineProperty(e, s, r.get ? r : {\n          enumerable: !0,\n          get: function get() {\n            return t[s];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n\n  var i = r(e);\n  /**\n     * query-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n\n  var n = /*#__PURE__*/function () {\n    function n() {\n      _classCallCheck(this, n);\n\n      this.listeners = [], this.subscribe = this.subscribe.bind(this);\n    }\n\n    _createClass(n, [{\n      key: \"subscribe\",\n      value: function subscribe(t) {\n        var _this = this;\n\n        return this.listeners.push(t), this.onSubscribe(), function () {\n          _this.listeners = _this.listeners.filter(function (e) {\n            return e !== t;\n          }), _this.onUnsubscribe();\n        };\n      }\n    }, {\n      key: \"hasListeners\",\n      value: function hasListeners() {\n        return this.listeners.length > 0;\n      }\n    }, {\n      key: \"onSubscribe\",\n      value: function onSubscribe() {}\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {}\n    }]);\n\n    return n;\n  }();\n\n  var o = \"undefined\" == typeof window;\n\n  function a() {}\n\n  function u(t) {\n    return \"number\" == typeof t && t >= 0 && t !== 1 / 0;\n  }\n\n  function c(t, e) {\n    return t.filter(function (t) {\n      return -1 === e.indexOf(t);\n    });\n  }\n\n  function h(t, e) {\n    return Math.max(t + (e || 0) - Date.now(), 0);\n  }\n\n  function l(t, e, s) {\n    return Q(t) ? \"function\" == typeof e ? _objectSpread(_objectSpread({}, s), {}, {\n      queryKey: t,\n      queryFn: e\n    }) : _objectSpread(_objectSpread({}, e), {}, {\n      queryKey: t\n    }) : t;\n  }\n\n  function d(t, e, s) {\n    return Q(t) ? \"function\" == typeof e ? _objectSpread(_objectSpread({}, s), {}, {\n      mutationKey: t,\n      mutationFn: e\n    }) : _objectSpread(_objectSpread({}, e), {}, {\n      mutationKey: t\n    }) : \"function\" == typeof t ? _objectSpread(_objectSpread({}, e), {}, {\n      mutationFn: t\n    }) : _objectSpread({}, t);\n  }\n\n  function f(t, e, s) {\n    return Q(t) ? [_objectSpread(_objectSpread({}, e), {}, {\n      queryKey: t\n    }), s] : [t || {}, e];\n  }\n\n  function p(t, e, s) {\n    return Q(t) ? [_objectSpread(_objectSpread({}, e), {}, {\n      mutationKey: t\n    }), s] : [t || {}, e];\n  }\n\n  function y(t, e) {\n    var _t$type = t.type,\n        s = _t$type === void 0 ? \"all\" : _t$type,\n        r = t.exact,\n        i = t.fetchStatus,\n        n = t.predicate,\n        o = t.queryKey,\n        a = t.stale;\n    if (Q(o)) if (r) {\n      if (e.queryHash !== m(o, e.options)) return !1;\n    } else if (!g(e.queryKey, o)) return !1;\n\n    if (\"all\" !== s) {\n      var _t = e.isActive();\n\n      if (\"active\" === s && !_t) return !1;\n      if (\"inactive\" === s && _t) return !1;\n    }\n\n    return (\"boolean\" != typeof a || e.isStale() === a) && (void 0 === i || i === e.state.fetchStatus) && !(n && !n(e));\n  }\n\n  function v(t, e) {\n    var s = t.exact,\n        r = t.fetching,\n        i = t.predicate,\n        n = t.mutationKey;\n\n    if (Q(n)) {\n      if (!e.options.mutationKey) return !1;\n\n      if (s) {\n        if (b(e.options.mutationKey) !== b(n)) return !1;\n      } else if (!g(e.options.mutationKey, n)) return !1;\n    }\n\n    return (\"boolean\" != typeof r || \"loading\" === e.state.status === r) && !(i && !i(e));\n  }\n\n  function m(t, e) {\n    return ((null == e ? void 0 : e.queryKeyHashFn) || b)(t);\n  }\n\n  function b(t) {\n    return JSON.stringify(t, function (t, e) {\n      return S(e) ? Object.keys(e).sort().reduce(function (t, s) {\n        return t[s] = e[s], t;\n      }, {}) : e;\n    });\n  }\n\n  function g(t, e) {\n    return O(t, e);\n  }\n\n  function O(t, e) {\n    return t === e || typeof t == typeof e && !(!t || !e || \"object\" != typeof t || \"object\" != typeof e) && !Object.keys(e).some(function (s) {\n      return !O(t[s], e[s]);\n    });\n  }\n\n  function C(t, e) {\n    if (t === e) return t;\n    var s = q(t) && q(e);\n\n    if (s || S(t) && S(e)) {\n      var _r = s ? t.length : Object.keys(t).length,\n          _i = s ? e : Object.keys(e),\n          _n = _i.length,\n          _o = s ? [] : {};\n\n      var _a = 0;\n\n      for (var _r2 = 0; _r2 < _n; _r2++) {\n        var _n2 = s ? _r2 : _i[_r2];\n\n        _o[_n2] = C(t[_n2], e[_n2]), _o[_n2] === t[_n2] && _a++;\n      }\n\n      return _r === _n && _a === _r ? t : _o;\n    }\n\n    return e;\n  }\n\n  function R(t, e) {\n    if (t && !e || e && !t) return !1;\n\n    for (var _s in t) {\n      if (t[_s] !== e[_s]) return !1;\n    }\n\n    return !0;\n  }\n\n  function q(t) {\n    return Array.isArray(t) && t.length === Object.keys(t).length;\n  }\n\n  function S(t) {\n    if (!P(t)) return !1;\n    var e = t.constructor;\n    if (void 0 === e) return !0;\n    var s = e.prototype;\n    return !!P(s) && !!s.hasOwnProperty(\"isPrototypeOf\");\n  }\n\n  function P(t) {\n    return \"[object Object]\" === Object.prototype.toString.call(t);\n  }\n\n  function Q(t) {\n    return Array.isArray(t);\n  }\n\n  function E(t) {\n    return new Promise(function (e) {\n      setTimeout(e, t);\n    });\n  }\n\n  function x(t) {\n    E(0).then(t);\n  }\n\n  function M(t, e, s) {\n    return null != s.isDataEqual && s.isDataEqual(t, e) ? t : \"function\" == typeof s.structuralSharing ? s.structuralSharing(t, e) : !1 !== s.structuralSharing ? C(t, e) : e;\n  }\n\n  var w = new ( /*#__PURE__*/function (_n3) {\n    _inherits(_class, _n3);\n\n    var _super = _createSuper(_class);\n\n    function _class() {\n      var _this2;\n\n      _classCallCheck(this, _class);\n\n      _this2 = _super.call(this), _this2.setup = function (t) {\n        if (!o && window.addEventListener) {\n          var _e = function _e() {\n            return t();\n          };\n\n          return window.addEventListener(\"visibilitychange\", _e, !1), window.addEventListener(\"focus\", _e, !1), function () {\n            window.removeEventListener(\"visibilitychange\", _e), window.removeEventListener(\"focus\", _e);\n          };\n        }\n      };\n      return _this2;\n    }\n\n    _createClass(_class, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        this.cleanup || this.setEventListener(this.setup);\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n      }\n    }, {\n      key: \"setEventListener\",\n      value: function setEventListener(t) {\n        var _this3 = this;\n\n        var e;\n        this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(function (t) {\n          \"boolean\" == typeof t ? _this3.setFocused(t) : _this3.onFocus();\n        });\n      }\n    }, {\n      key: \"setFocused\",\n      value: function setFocused(t) {\n        this.focused = t, t && this.onFocus();\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        this.listeners.forEach(function (t) {\n          t();\n        });\n      }\n    }, {\n      key: \"isFocused\",\n      value: function isFocused() {\n        return \"boolean\" == typeof this.focused ? this.focused : \"undefined\" == typeof document || [void 0, \"visible\", \"prerender\"].includes(document.visibilityState);\n      }\n    }]);\n\n    return _class;\n  }(n))();\n  var F = new ( /*#__PURE__*/function (_n4) {\n    _inherits(_class2, _n4);\n\n    var _super2 = _createSuper(_class2);\n\n    function _class2() {\n      var _this4;\n\n      _classCallCheck(this, _class2);\n\n      _this4 = _super2.call(this), _this4.setup = function (t) {\n        if (!o && window.addEventListener) {\n          var _e2 = function _e2() {\n            return t();\n          };\n\n          return window.addEventListener(\"online\", _e2, !1), window.addEventListener(\"offline\", _e2, !1), function () {\n            window.removeEventListener(\"online\", _e2), window.removeEventListener(\"offline\", _e2);\n          };\n        }\n      };\n      return _this4;\n    }\n\n    _createClass(_class2, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        this.cleanup || this.setEventListener(this.setup);\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n      }\n    }, {\n      key: \"setEventListener\",\n      value: function setEventListener(t) {\n        var _this5 = this;\n\n        var e;\n        this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(function (t) {\n          \"boolean\" == typeof t ? _this5.setOnline(t) : _this5.onOnline();\n        });\n      }\n    }, {\n      key: \"setOnline\",\n      value: function setOnline(t) {\n        this.online = t, t && this.onOnline();\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        this.listeners.forEach(function (t) {\n          t();\n        });\n      }\n    }, {\n      key: \"isOnline\",\n      value: function isOnline() {\n        return \"boolean\" == typeof this.online ? this.online : \"undefined\" == typeof navigator || void 0 === navigator.onLine || navigator.onLine;\n      }\n    }]);\n\n    return _class2;\n  }(n))();\n\n  function A(t) {\n    return Math.min(1e3 * Math.pow(2, t), 3e4);\n  }\n\n  function D(t) {\n    return \"online\" !== (null != t ? t : \"online\") || F.isOnline();\n  }\n\n  var U = /*#__PURE__*/_createClass(function U(t) {\n    _classCallCheck(this, U);\n\n    this.revert = null == t ? void 0 : t.revert, this.silent = null == t ? void 0 : t.silent;\n  });\n\n  function I(t) {\n    return t instanceof U;\n  }\n\n  function T(t) {\n    var e,\n        s,\n        r,\n        i = !1,\n        n = 0,\n        o = !1;\n\n    var a = new Promise(function (t, e) {\n      s = t, r = e;\n    }),\n        u = function u() {\n      return !w.isFocused() || \"always\" !== t.networkMode && !F.isOnline();\n    },\n        c = function c(r) {\n      o || (o = !0, null == t.onSuccess || t.onSuccess(r), null == e || e(), s(r));\n    },\n        h = function h(s) {\n      o || (o = !0, null == t.onError || t.onError(s), null == e || e(), r(s));\n    },\n        l = function l() {\n      return new Promise(function (s) {\n        e = function e(t) {\n          if (o || !u()) return s(t);\n        }, null == t.onPause || t.onPause();\n      }).then(function () {\n        e = void 0, o || null == t.onContinue || t.onContinue();\n      });\n    },\n        d = function d() {\n      if (o) return;\n      var e;\n\n      try {\n        e = t.fn();\n      } catch (t) {\n        e = Promise.reject(t);\n      }\n\n      Promise.resolve(e).then(c).catch(function (e) {\n        var s, r;\n        if (o) return;\n        var a = null != (s = t.retry) ? s : 3,\n            c = null != (r = t.retryDelay) ? r : A,\n            f = \"function\" == typeof c ? c(n, e) : c,\n            p = !0 === a || \"number\" == typeof a && n < a || \"function\" == typeof a && a(n, e);\n        !i && p ? (n++, null == t.onFail || t.onFail(n, e), E(f).then(function () {\n          if (u()) return l();\n        }).then(function () {\n          i ? h(e) : d();\n        })) : h(e);\n      });\n    };\n\n    return D(t.networkMode) ? d() : l().then(d), {\n      promise: a,\n      cancel: function cancel(e) {\n        o || (h(new U(e)), null == t.abort || t.abort());\n      },\n      continue: function _continue() {\n        null == e || e();\n      },\n      cancelRetry: function cancelRetry() {\n        i = !0;\n      },\n      continueRetry: function continueRetry() {\n        i = !1;\n      }\n    };\n  }\n\n  var K = console;\n\n  var k = function () {\n    var t = [],\n        e = 0,\n        s = function s(t) {\n      t();\n    },\n        r = function r(t) {\n      t();\n    };\n\n    var i = function i(r) {\n      e ? t.push(r) : x(function () {\n        s(r);\n      });\n    },\n        n = function n() {\n      var e = t;\n      t = [], e.length && x(function () {\n        r(function () {\n          e.forEach(function (t) {\n            s(t);\n          });\n        });\n      });\n    };\n\n    return {\n      batch: function batch(t) {\n        var s;\n        e++;\n\n        try {\n          s = t();\n        } finally {\n          e--, e || n();\n        }\n\n        return s;\n      },\n      batchCalls: function batchCalls(t) {\n        return function () {\n          for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n            e[_key] = arguments[_key];\n          }\n\n          i(function () {\n            t.apply(void 0, e);\n          });\n        };\n      },\n      schedule: i,\n      setNotifyFunction: function setNotifyFunction(t) {\n        s = t;\n      },\n      setBatchNotifyFunction: function setBatchNotifyFunction(t) {\n        r = t;\n      }\n    };\n  }();\n\n  var L = /*#__PURE__*/function () {\n    function L() {\n      _classCallCheck(this, L);\n    }\n\n    _createClass(L, [{\n      key: \"destroy\",\n      value: function destroy() {\n        this.clearGcTimeout();\n      }\n    }, {\n      key: \"scheduleGc\",\n      value: function scheduleGc() {\n        var _this6 = this;\n\n        this.clearGcTimeout(), u(this.cacheTime) && (this.gcTimeout = setTimeout(function () {\n          _this6.optionalRemove();\n        }, this.cacheTime));\n      }\n    }, {\n      key: \"updateCacheTime\",\n      value: function updateCacheTime(t) {\n        this.cacheTime = Math.max(this.cacheTime || 0, null != t ? t : o ? 1 / 0 : 3e5);\n      }\n    }, {\n      key: \"clearGcTimeout\",\n      value: function clearGcTimeout() {\n        this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);\n      }\n    }]);\n\n    return L;\n  }();\n\n  var j = /*#__PURE__*/function (_L) {\n    _inherits(j, _L);\n\n    var _super3 = _createSuper(j);\n\n    function j(t) {\n      var _this7;\n\n      _classCallCheck(this, j);\n\n      _this7 = _super3.call(this), _this7.abortSignalConsumed = !1, _this7.defaultOptions = t.defaultOptions, _this7.setOptions(t.options), _this7.observers = [], _this7.cache = t.cache, _this7.logger = t.logger || K, _this7.queryKey = t.queryKey, _this7.queryHash = t.queryHash, _this7.initialState = t.state || function (t) {\n        var e = \"function\" == typeof t.initialData ? t.initialData() : t.initialData,\n            s = void 0 !== t.initialData ? \"function\" == typeof t.initialDataUpdatedAt ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0,\n            r = void 0 !== e;\n        return {\n          data: e,\n          dataUpdateCount: 0,\n          dataUpdatedAt: r ? null != s ? s : Date.now() : 0,\n          error: null,\n          errorUpdateCount: 0,\n          errorUpdatedAt: 0,\n          fetchFailureCount: 0,\n          fetchMeta: null,\n          isInvalidated: !1,\n          status: r ? \"success\" : \"loading\",\n          fetchStatus: \"idle\"\n        };\n      }(_this7.options), _this7.state = _this7.initialState, _this7.meta = t.meta;\n      return _this7;\n    }\n\n    _createClass(j, [{\n      key: \"setOptions\",\n      value: function setOptions(t) {\n        this.options = _objectSpread(_objectSpread({}, this.defaultOptions), t), this.meta = null == t ? void 0 : t.meta, this.updateCacheTime(this.options.cacheTime);\n      }\n    }, {\n      key: \"optionalRemove\",\n      value: function optionalRemove() {\n        this.observers.length || \"idle\" !== this.state.fetchStatus || this.cache.remove(this);\n      }\n    }, {\n      key: \"setData\",\n      value: function setData(t, e) {\n        var s = M(this.state.data, t, this.options);\n        return this.dispatch({\n          data: s,\n          type: \"success\",\n          dataUpdatedAt: null == e ? void 0 : e.updatedAt,\n          manual: null == e ? void 0 : e.manual\n        }), s;\n      }\n    }, {\n      key: \"setState\",\n      value: function setState(t, e) {\n        this.dispatch({\n          type: \"setState\",\n          state: t,\n          setStateOptions: e\n        });\n      }\n    }, {\n      key: \"cancel\",\n      value: function cancel(t) {\n        var e;\n        var s = this.promise;\n        return null == (e = this.retryer) || e.cancel(t), s ? s.then(a).catch(a) : Promise.resolve();\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        _get(_getPrototypeOf(j.prototype), \"destroy\", this).call(this), this.cancel({\n          silent: !0\n        });\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.destroy(), this.setState(this.initialState);\n      }\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return this.observers.some(function (t) {\n          return !1 !== t.options.enabled;\n        });\n      }\n    }, {\n      key: \"isDisabled\",\n      value: function isDisabled() {\n        return this.getObserversCount() > 0 && !this.isActive();\n      }\n    }, {\n      key: \"isStale\",\n      value: function isStale() {\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (t) {\n          return t.getCurrentResult().isStale;\n        });\n      }\n    }, {\n      key: \"isStaleByTime\",\n      value: function isStaleByTime() {\n        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || !h(this.state.dataUpdatedAt, t);\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        var t;\n        var e = this.observers.find(function (t) {\n          return t.shouldFetchOnWindowFocus();\n        });\n        e && e.refetch({\n          cancelRefetch: !1\n        }), null == (t = this.retryer) || t.continue();\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        var t;\n        var e = this.observers.find(function (t) {\n          return t.shouldFetchOnReconnect();\n        });\n        e && e.refetch({\n          cancelRefetch: !1\n        }), null == (t = this.retryer) || t.continue();\n      }\n    }, {\n      key: \"addObserver\",\n      value: function addObserver(t) {\n        -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({\n          type: \"observerAdded\",\n          query: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"removeObserver\",\n      value: function removeObserver(t) {\n        -1 !== this.observers.indexOf(t) && (this.observers = this.observers.filter(function (e) {\n          return e !== t;\n        }), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({\n          revert: !0\n        }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({\n          type: \"observerRemoved\",\n          query: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"getObserversCount\",\n      value: function getObserversCount() {\n        return this.observers.length;\n      }\n    }, {\n      key: \"invalidate\",\n      value: function invalidate() {\n        this.state.isInvalidated || this.dispatch({\n          type: \"invalidate\"\n        });\n      }\n    }, {\n      key: \"fetch\",\n      value: function fetch(t, e) {\n        var _this8 = this;\n\n        var s, r;\n        if (\"idle\" !== this.state.fetchStatus) if (this.state.dataUpdatedAt && null != e && e.cancelRefetch) this.cancel({\n          silent: !0\n        });else if (this.promise) {\n          var i;\n          return null == (i = this.retryer) || i.continueRetry(), this.promise;\n        }\n\n        if (t && this.setOptions(t), !this.options.queryFn) {\n          var _t2 = this.observers.find(function (t) {\n            return t.options.queryFn;\n          });\n\n          _t2 && this.setOptions(_t2.options);\n        }\n\n        Array.isArray(this.options.queryKey);\n\n        var n = function () {\n          if (\"function\" == typeof AbortController) return new AbortController();\n        }(),\n            o = {\n          queryKey: this.queryKey,\n          pageParam: void 0,\n          meta: this.meta\n        },\n            a = function a(t) {\n          Object.defineProperty(t, \"signal\", {\n            enumerable: !0,\n            get: function get() {\n              if (n) return _this8.abortSignalConsumed = !0, n.signal;\n            }\n          });\n        };\n\n        a(o);\n        var u = {\n          fetchOptions: e,\n          options: this.options,\n          queryKey: this.queryKey,\n          state: this.state,\n          fetchFn: function fetchFn() {\n            return _this8.options.queryFn ? (_this8.abortSignalConsumed = !1, _this8.options.queryFn(o)) : Promise.reject(\"Missing queryFn\");\n          },\n          meta: this.meta\n        };\n        var c;\n        (a(u), null == (s = this.options.behavior) || s.onFetch(u), this.revertState = this.state, \"idle\" === this.state.fetchStatus || this.state.fetchMeta !== (null == (r = u.fetchOptions) ? void 0 : r.meta)) && this.dispatch({\n          type: \"fetch\",\n          meta: null == (c = u.fetchOptions) ? void 0 : c.meta\n        });\n\n        var h = function h(t) {\n          var e, s;\n          (I(t) && t.silent || _this8.dispatch({\n            type: \"error\",\n            error: t\n          }), I(t)) || null == (e = (s = _this8.cache.config).onError) || e.call(s, t, _this8);\n          _this8.isFetchingOptimistic || _this8.scheduleGc(), _this8.isFetchingOptimistic = !1;\n        };\n\n        return this.retryer = T({\n          fn: u.fetchFn,\n          abort: null == n ? void 0 : n.abort.bind(n),\n          onSuccess: function onSuccess(t) {\n            var e, s;\n            void 0 !== t ? (_this8.setData(t), null == (e = (s = _this8.cache.config).onSuccess) || e.call(s, t, _this8), _this8.isFetchingOptimistic || _this8.scheduleGc(), _this8.isFetchingOptimistic = !1) : h(new Error(\"Query data cannot be undefined\"));\n          },\n          onError: h,\n          onFail: function onFail() {\n            _this8.dispatch({\n              type: \"failed\"\n            });\n          },\n          onPause: function onPause() {\n            _this8.dispatch({\n              type: \"pause\"\n            });\n          },\n          onContinue: function onContinue() {\n            _this8.dispatch({\n              type: \"continue\"\n            });\n          },\n          retry: u.options.retry,\n          retryDelay: u.options.retryDelay,\n          networkMode: u.options.networkMode\n        }), this.promise = this.retryer.promise, this.promise;\n      }\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(t) {\n        var _this9 = this;\n\n        this.state = function (e) {\n          var s, r;\n\n          switch (t.type) {\n            case \"failed\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                fetchFailureCount: e.fetchFailureCount + 1\n              });\n\n            case \"pause\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                fetchStatus: \"paused\"\n              });\n\n            case \"continue\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                fetchStatus: \"fetching\"\n              });\n\n            case \"fetch\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                fetchFailureCount: 0,\n                fetchMeta: null != (s = t.meta) ? s : null,\n                fetchStatus: D(_this9.options.networkMode) ? \"fetching\" : \"paused\"\n              }, !e.dataUpdatedAt && {\n                error: null,\n                status: \"loading\"\n              });\n\n            case \"success\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                data: t.data,\n                dataUpdateCount: e.dataUpdateCount + 1,\n                dataUpdatedAt: null != (r = t.dataUpdatedAt) ? r : Date.now(),\n                error: null,\n                isInvalidated: !1,\n                status: \"success\"\n              }, !t.manual && {\n                fetchStatus: \"idle\",\n                fetchFailureCount: 0\n              });\n\n            case \"error\":\n              var _i2 = t.error;\n              return I(_i2) && _i2.revert && _this9.revertState ? _objectSpread({}, _this9.revertState) : _objectSpread(_objectSpread({}, e), {}, {\n                error: _i2,\n                errorUpdateCount: e.errorUpdateCount + 1,\n                errorUpdatedAt: Date.now(),\n                fetchFailureCount: e.fetchFailureCount + 1,\n                fetchStatus: \"idle\",\n                status: \"error\"\n              });\n\n            case \"invalidate\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                isInvalidated: !0\n              });\n\n            case \"setState\":\n              return _objectSpread(_objectSpread({}, e), t.state);\n          }\n        }(this.state), k.batch(function () {\n          _this9.observers.forEach(function (e) {\n            e.onQueryUpdate(t);\n          }), _this9.cache.notify({\n            query: _this9,\n            type: \"updated\",\n            action: t\n          });\n        });\n      }\n    }]);\n\n    return j;\n  }(L);\n\n  var H = /*#__PURE__*/function (_n5) {\n    _inherits(H, _n5);\n\n    var _super4 = _createSuper(H);\n\n    function H(t) {\n      var _this10;\n\n      _classCallCheck(this, H);\n\n      _this10 = _super4.call(this), _this10.config = t || {}, _this10.queries = [], _this10.queriesMap = {};\n      return _this10;\n    }\n\n    _createClass(H, [{\n      key: \"build\",\n      value: function build(t, e, s) {\n        var r;\n        var i = e.queryKey,\n            n = null != (r = e.queryHash) ? r : m(i, e);\n        var o = this.get(n);\n        return o || (o = new j({\n          cache: this,\n          logger: t.getLogger(),\n          queryKey: i,\n          queryHash: n,\n          options: t.defaultQueryOptions(e),\n          state: s,\n          defaultOptions: t.getQueryDefaults(i),\n          meta: e.meta\n        }), this.add(o)), o;\n      }\n    }, {\n      key: \"add\",\n      value: function add(t) {\n        this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({\n          type: \"added\",\n          query: t\n        }));\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(t) {\n        var e = this.queriesMap[t.queryHash];\n        e && (t.destroy(), this.queries = this.queries.filter(function (e) {\n          return e !== t;\n        }), e === t && delete this.queriesMap[t.queryHash], this.notify({\n          type: \"removed\",\n          query: t\n        }));\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this11 = this;\n\n        k.batch(function () {\n          _this11.queries.forEach(function (t) {\n            _this11.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function get(t) {\n        return this.queriesMap[t];\n      }\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        return this.queries;\n      }\n    }, {\n      key: \"find\",\n      value: function find(t, e) {\n        var _f = f(t, e),\n            _f2 = _slicedToArray(_f, 1),\n            s = _f2[0];\n\n        return void 0 === s.exact && (s.exact = !0), this.queries.find(function (t) {\n          return y(s, t);\n        });\n      }\n    }, {\n      key: \"findAll\",\n      value: function findAll(t, e) {\n        var _f3 = f(t, e),\n            _f4 = _slicedToArray(_f3, 1),\n            s = _f4[0];\n\n        return Object.keys(s).length > 0 ? this.queries.filter(function (t) {\n          return y(s, t);\n        }) : this.queries;\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this12 = this;\n\n        k.batch(function () {\n          _this12.listeners.forEach(function (e) {\n            e(t);\n          });\n        });\n      }\n    }, {\n      key: \"onFocus\",\n      value: function onFocus() {\n        var _this13 = this;\n\n        k.batch(function () {\n          _this13.queries.forEach(function (t) {\n            t.onFocus();\n          });\n        });\n      }\n    }, {\n      key: \"onOnline\",\n      value: function onOnline() {\n        var _this14 = this;\n\n        k.batch(function () {\n          _this14.queries.forEach(function (t) {\n            t.onOnline();\n          });\n        });\n      }\n    }]);\n\n    return H;\n  }(n);\n\n  var N = /*#__PURE__*/function (_L2) {\n    _inherits(N, _L2);\n\n    var _super5 = _createSuper(N);\n\n    function N(t) {\n      var _this15;\n\n      _classCallCheck(this, N);\n\n      _this15 = _super5.call(this), _this15.options = _objectSpread(_objectSpread({}, t.defaultOptions), t.options), _this15.mutationId = t.mutationId, _this15.mutationCache = t.mutationCache, _this15.logger = t.logger || K, _this15.observers = [], _this15.state = t.state || B(), _this15.meta = t.meta, _this15.updateCacheTime(_this15.options.cacheTime), _this15.scheduleGc();\n      return _this15;\n    }\n\n    _createClass(N, [{\n      key: \"setState\",\n      value: function setState(t) {\n        this.dispatch({\n          type: \"setState\",\n          state: t\n        });\n      }\n    }, {\n      key: \"addObserver\",\n      value: function addObserver(t) {\n        -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({\n          type: \"observerAdded\",\n          mutation: this,\n          observer: t\n        }));\n      }\n    }, {\n      key: \"removeObserver\",\n      value: function removeObserver(t) {\n        this.observers = this.observers.filter(function (e) {\n          return e !== t;\n        }), this.scheduleGc(), this.mutationCache.notify({\n          type: \"observerRemoved\",\n          mutation: this,\n          observer: t\n        });\n      }\n    }, {\n      key: \"optionalRemove\",\n      value: function optionalRemove() {\n        this.observers.length || (\"loading\" === this.state.status ? this.scheduleGc() : this.mutationCache.remove(this));\n      }\n    }, {\n      key: \"continue\",\n      value: function _continue() {\n        return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();\n      }\n    }, {\n      key: \"execute\",\n      value: function () {\n        var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _this16 = this;\n\n          var t, e, s, r, i, n, o, a, u, c, h, l, _t3, _d, d, f, p, y, v, m;\n\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  t = function t() {\n                    var t;\n                    return _this16.retryer = T({\n                      fn: function fn() {\n                        return _this16.options.mutationFn ? _this16.options.mutationFn(_this16.state.variables) : Promise.reject(\"No mutationFn found\");\n                      },\n                      onFail: function onFail() {\n                        _this16.dispatch({\n                          type: \"failed\"\n                        });\n                      },\n                      onPause: function onPause() {\n                        _this16.dispatch({\n                          type: \"pause\"\n                        });\n                      },\n                      onContinue: function onContinue() {\n                        _this16.dispatch({\n                          type: \"continue\"\n                        });\n                      },\n                      retry: null != (t = _this16.options.retry) ? t : 0,\n                      retryDelay: _this16.options.retryDelay,\n                      networkMode: _this16.options.networkMode\n                    }), _this16.retryer.promise;\n                  }, e = \"loading\" === this.state.status;\n                  _context.prev = 1;\n\n                  if (e) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  this.dispatch({\n                    type: \"loading\",\n                    variables: this.options.variables\n                  }), null == (u = (c = this.mutationCache.config).onMutate) || u.call(c, this.state.variables, this);\n                  _context.next = 6;\n                  return null == (h = (l = this.options).onMutate) ? void 0 : h.call(l, this.state.variables);\n\n                case 6:\n                  _t3 = _context.sent;\n                  _t3 !== this.state.context && this.dispatch({\n                    type: \"loading\",\n                    context: _t3,\n                    variables: this.state.variables\n                  });\n\n                case 8:\n                  _context.next = 10;\n                  return t();\n\n                case 10:\n                  _d = _context.sent;\n                  null == (s = (r = this.mutationCache.config).onSuccess) || s.call(r, _d, this.state.variables, this.state.context, this);\n                  _context.next = 14;\n                  return null == (i = (n = this.options).onSuccess) ? void 0 : i.call(n, _d, this.state.variables, this.state.context);\n\n                case 14:\n                  _context.next = 16;\n                  return null == (o = (a = this.options).onSettled) ? void 0 : o.call(a, _d, null, this.state.variables, this.state.context);\n\n                case 16:\n                  this.dispatch({\n                    type: \"success\",\n                    data: _d\n                  });\n                  return _context.abrupt(\"return\", _d);\n\n                case 20:\n                  _context.prev = 20;\n                  _context.t0 = _context[\"catch\"](1);\n                  _context.prev = 22;\n                  null == (d = (f = this.mutationCache.config).onError) || d.call(f, _context.t0, this.state.variables, this.state.context, this);\n                  _context.next = 26;\n                  return null == (p = (y = this.options).onError) ? void 0 : p.call(y, _context.t0, this.state.variables, this.state.context);\n\n                case 26:\n                  _context.next = 28;\n                  return null == (v = (m = this.options).onSettled) ? void 0 : v.call(m, void 0, _context.t0, this.state.variables, this.state.context);\n\n                case 28:\n                  throw _context.t0;\n\n                case 29:\n                  _context.prev = 29;\n                  this.dispatch({\n                    type: \"error\",\n                    error: _context.t0\n                  });\n                  return _context.finish(29);\n\n                case 32:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[1, 20], [22,, 29, 32]]);\n        }));\n\n        function execute() {\n          return _execute.apply(this, arguments);\n        }\n\n        return execute;\n      }()\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(t) {\n        var _this17 = this;\n\n        this.state = function (e) {\n          switch (t.type) {\n            case \"failed\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                failureCount: e.failureCount + 1\n              });\n\n            case \"pause\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                isPaused: !0\n              });\n\n            case \"continue\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                isPaused: !1\n              });\n\n            case \"loading\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                context: t.context,\n                data: void 0,\n                error: null,\n                isPaused: !D(_this17.options.networkMode),\n                status: \"loading\",\n                variables: t.variables\n              });\n\n            case \"success\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                data: t.data,\n                error: null,\n                status: \"success\",\n                isPaused: !1\n              });\n\n            case \"error\":\n              return _objectSpread(_objectSpread({}, e), {}, {\n                data: void 0,\n                error: t.error,\n                failureCount: e.failureCount + 1,\n                isPaused: !1,\n                status: \"error\"\n              });\n\n            case \"setState\":\n              return _objectSpread(_objectSpread({}, e), t.state);\n          }\n        }(this.state), k.batch(function () {\n          _this17.observers.forEach(function (e) {\n            e.onMutationUpdate(t);\n          }), _this17.mutationCache.notify({\n            mutation: _this17,\n            type: \"updated\",\n            action: t\n          });\n        });\n      }\n    }]);\n\n    return N;\n  }(L);\n\n  function B() {\n    return {\n      context: void 0,\n      data: void 0,\n      error: null,\n      failureCount: 0,\n      isPaused: !1,\n      status: \"idle\",\n      variables: void 0\n    };\n  }\n\n  var G = /*#__PURE__*/function (_n6) {\n    _inherits(G, _n6);\n\n    var _super6 = _createSuper(G);\n\n    function G(t) {\n      var _this18;\n\n      _classCallCheck(this, G);\n\n      _this18 = _super6.call(this), _this18.config = t || {}, _this18.mutations = [], _this18.mutationId = 0;\n      return _this18;\n    }\n\n    _createClass(G, [{\n      key: \"build\",\n      value: function build(t, e, s) {\n        var r = new N({\n          mutationCache: this,\n          logger: t.getLogger(),\n          mutationId: ++this.mutationId,\n          options: t.defaultMutationOptions(e),\n          state: s,\n          defaultOptions: e.mutationKey ? t.getMutationDefaults(e.mutationKey) : void 0,\n          meta: e.meta\n        });\n        return this.add(r), r;\n      }\n    }, {\n      key: \"add\",\n      value: function add(t) {\n        this.mutations.push(t), this.notify({\n          type: \"added\",\n          mutation: t\n        });\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(t) {\n        this.mutations = this.mutations.filter(function (e) {\n          return e !== t;\n        }), this.notify({\n          type: \"removed\",\n          mutation: t\n        });\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this19 = this;\n\n        k.batch(function () {\n          _this19.mutations.forEach(function (t) {\n            _this19.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        return this.mutations;\n      }\n    }, {\n      key: \"find\",\n      value: function find(t) {\n        return void 0 === t.exact && (t.exact = !0), this.mutations.find(function (e) {\n          return v(t, e);\n        });\n      }\n    }, {\n      key: \"findAll\",\n      value: function findAll(t) {\n        return this.mutations.filter(function (e) {\n          return v(t, e);\n        });\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this20 = this;\n\n        k.batch(function () {\n          _this20.listeners.forEach(function (e) {\n            e(t);\n          });\n        });\n      }\n    }, {\n      key: \"resumePausedMutations\",\n      value: function resumePausedMutations() {\n        var t = this.mutations.filter(function (t) {\n          return t.state.isPaused;\n        });\n        return k.batch(function () {\n          return t.reduce(function (t, e) {\n            return t.then(function () {\n              return e.continue().catch(a);\n            });\n          }, Promise.resolve());\n        });\n      }\n    }]);\n\n    return G;\n  }(n);\n\n  function _() {\n    return {\n      onFetch: function onFetch(t) {\n        t.fetchFn = function () {\n          var e, s, r, i, n, o;\n          var a = null == (e = t.fetchOptions) || null == (s = e.meta) ? void 0 : s.refetchPage,\n              u = null == (r = t.fetchOptions) || null == (i = r.meta) ? void 0 : i.fetchMore,\n              c = null == u ? void 0 : u.pageParam,\n              h = \"forward\" === (null == u ? void 0 : u.direction),\n              l = \"backward\" === (null == u ? void 0 : u.direction),\n              d = (null == (n = t.state.data) ? void 0 : n.pages) || [],\n              f = (null == (o = t.state.data) ? void 0 : o.pageParams) || [];\n          var p = f,\n              y = !1;\n\n          var v = t.options.queryFn || function () {\n            return Promise.reject(\"Missing queryFn\");\n          },\n              m = function m(t, e, s, r) {\n            return p = r ? [e].concat(_toConsumableArray(p)) : [].concat(_toConsumableArray(p), [e]), r ? [s].concat(_toConsumableArray(t)) : [].concat(_toConsumableArray(t), [s]);\n          },\n              b = function b(e, s, r, i) {\n            if (y) return Promise.reject(\"Cancelled\");\n            if (void 0 === r && !s && e.length) return Promise.resolve(e);\n            var n = {\n              queryKey: t.queryKey,\n              pageParam: r,\n              meta: t.meta\n            };\n            var o;\n            o = n, Object.defineProperty(o, \"signal\", {\n              enumerable: !0,\n              get: function get() {\n                var e, s;\n                return null != (e = t.signal) && e.aborted ? y = !0 : null == (s = t.signal) || s.addEventListener(\"abort\", function () {\n                  y = !0;\n                }), t.signal;\n              }\n            });\n            var a = v(n);\n            return Promise.resolve(a).then(function (t) {\n              return m(e, r, t, i);\n            });\n          };\n\n          var g;\n          if (d.length) {\n            if (h) {\n              var _e3 = void 0 !== c,\n                  _s2 = _e3 ? c : W(t.options, d);\n\n              g = b(d, _e3, _s2);\n            } else if (l) {\n              var _e4 = void 0 !== c,\n                  _s3 = _e4 ? c : z(t.options, d);\n\n              g = b(d, _e4, _s3, !0);\n            } else {\n              (function () {\n                p = [];\n                var e = void 0 === t.options.getNextPageParam;\n                g = !a || !d[0] || a(d[0], 0, d) ? b([], e, f[0]) : Promise.resolve(m([], f[0], d[0]));\n\n                var _loop = function _loop(_s4) {\n                  g = g.then(function (r) {\n                    if (!a || !d[_s4] || a(d[_s4], _s4, d)) {\n                      var _i3 = e ? f[_s4] : W(t.options, r);\n\n                      return b(r, e, _i3);\n                    }\n\n                    return Promise.resolve(m(r, f[_s4], d[_s4]));\n                  });\n                };\n\n                for (var _s4 = 1; _s4 < d.length; _s4++) {\n                  _loop(_s4);\n                }\n              })();\n            }\n          } else g = b([]);\n          return g.then(function (t) {\n            return {\n              pages: t,\n              pageParams: p\n            };\n          });\n        };\n      }\n    };\n  }\n\n  function W(t, e) {\n    return null == t.getNextPageParam ? void 0 : t.getNextPageParam(e[e.length - 1], e);\n  }\n\n  function z(t, e) {\n    return null == t.getPreviousPageParam ? void 0 : t.getPreviousPageParam(e[0], e);\n  }\n\n  function J(t, e) {\n    if (t.getNextPageParam && Array.isArray(e)) {\n      var s = W(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n\n  function V(t, e) {\n    if (t.getPreviousPageParam && Array.isArray(e)) {\n      var s = z(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n\n  var X = /*#__PURE__*/function (_n7) {\n    _inherits(X, _n7);\n\n    var _super7 = _createSuper(X);\n\n    function X(t, e) {\n      var _this21;\n\n      _classCallCheck(this, X);\n\n      _this21 = _super7.call(this), _this21.client = t, _this21.options = e, _this21.trackedProps = new Set(), _this21.selectError = null, _this21.bindMethods(), _this21.setOptions(e);\n      return _this21;\n    }\n\n    _createClass(X, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);\n      }\n    }, {\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        1 === this.listeners.length && (this.currentQuery.addObserver(this), Y(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        this.listeners.length || this.destroy();\n      }\n    }, {\n      key: \"shouldFetchOnReconnect\",\n      value: function shouldFetchOnReconnect() {\n        return Z(this.currentQuery, this.options, this.options.refetchOnReconnect);\n      }\n    }, {\n      key: \"shouldFetchOnWindowFocus\",\n      value: function shouldFetchOnWindowFocus() {\n        return Z(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.listeners = [], this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t, e) {\n        var s = this.options,\n            r = this.currentQuery;\n        if (this.options = this.client.defaultQueryOptions(t), R(s, this.options) || this.client.getQueryCache().notify({\n          type: \"observerOptionsUpdated\",\n          query: this.currentQuery,\n          observer: this\n        }), void 0 !== this.options.enabled && \"boolean\" != typeof this.options.enabled) throw new Error(\"Expected enabled to be a boolean\");\n        this.options.queryKey || (this.options.queryKey = s.queryKey), this.updateQuery();\n        var i = this.hasListeners();\n        i && $(this.currentQuery, r, this.options, s) && this.executeFetch(), this.updateResult(e), !i || this.currentQuery === r && this.options.enabled === s.enabled && this.options.staleTime === s.staleTime || this.updateStaleTimeout();\n        var n = this.computeRefetchInterval();\n        !i || this.currentQuery === r && this.options.enabled === s.enabled && n === this.currentRefetchInterval || this.updateRefetchInterval(n);\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        var e = this.client.getQueryCache().build(this.client, t);\n        return this.createResult(e, t);\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.currentResult;\n      }\n    }, {\n      key: \"trackResult\",\n      value: function trackResult(t) {\n        var _this22 = this;\n\n        var e = {};\n        return Object.keys(t).forEach(function (s) {\n          Object.defineProperty(e, s, {\n            configurable: !1,\n            enumerable: !0,\n            get: function get() {\n              return _this22.trackedProps.add(s), t[s];\n            }\n          });\n        }), e;\n      }\n    }, {\n      key: \"getCurrentQuery\",\n      value: function getCurrentQuery() {\n        return this.currentQuery;\n      }\n    }, {\n      key: \"remove\",\n      value: function remove() {\n        this.client.getQueryCache().remove(this.currentQuery);\n      }\n    }, {\n      key: \"refetch\",\n      value: function refetch() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref.refetchPage,\n            e = _objectWithoutProperties(_ref, _excluded);\n\n        return this.fetch(_objectSpread(_objectSpread({}, e), {}, {\n          meta: {\n            refetchPage: t\n          }\n        }));\n      }\n    }, {\n      key: \"fetchOptimistic\",\n      value: function fetchOptimistic(t) {\n        var _this23 = this;\n\n        var e = this.client.defaultQueryOptions(t),\n            s = this.client.getQueryCache().build(this.client, e);\n        return s.isFetchingOptimistic = !0, s.fetch().then(function () {\n          return _this23.createResult(s, e);\n        });\n      }\n    }, {\n      key: \"fetch\",\n      value: function fetch(t) {\n        var _this24 = this;\n\n        var e;\n        return this.executeFetch(_objectSpread(_objectSpread({}, t), {}, {\n          cancelRefetch: null == (e = t.cancelRefetch) || e\n        })).then(function () {\n          return _this24.updateResult(), _this24.currentResult;\n        });\n      }\n    }, {\n      key: \"executeFetch\",\n      value: function executeFetch(t) {\n        this.updateQuery();\n        var e = this.currentQuery.fetch(this.options, t);\n        return null != t && t.throwOnError || (e = e.catch(a)), e;\n      }\n    }, {\n      key: \"updateStaleTimeout\",\n      value: function updateStaleTimeout() {\n        var _this25 = this;\n\n        if (this.clearStaleTimeout(), o || this.currentResult.isStale || !u(this.options.staleTime)) return;\n        var t = h(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;\n        this.staleTimeoutId = setTimeout(function () {\n          _this25.currentResult.isStale || _this25.updateResult();\n        }, t);\n      }\n    }, {\n      key: \"computeRefetchInterval\",\n      value: function computeRefetchInterval() {\n        var t;\n        return \"function\" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (t = this.options.refetchInterval) && t;\n      }\n    }, {\n      key: \"updateRefetchInterval\",\n      value: function updateRefetchInterval(t) {\n        var _this26 = this;\n\n        this.clearRefetchInterval(), this.currentRefetchInterval = t, !o && !1 !== this.options.enabled && u(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval(function () {\n          (_this26.options.refetchIntervalInBackground || w.isFocused()) && _this26.executeFetch();\n        }, this.currentRefetchInterval));\n      }\n    }, {\n      key: \"updateTimers\",\n      value: function updateTimers() {\n        this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());\n      }\n    }, {\n      key: \"clearStaleTimeout\",\n      value: function clearStaleTimeout() {\n        this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);\n      }\n    }, {\n      key: \"clearRefetchInterval\",\n      value: function clearRefetchInterval() {\n        this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);\n      }\n    }, {\n      key: \"createResult\",\n      value: function createResult(t, e) {\n        var s = this.currentQuery,\n            r = this.options,\n            i = this.currentResult,\n            n = this.currentResultState,\n            o = this.currentResultOptions,\n            a = t !== s,\n            u = a ? t.state : this.currentQueryInitialState,\n            c = a ? this.currentResult : this.previousQueryResult,\n            h = t.state;\n        var l,\n            d = h.dataUpdatedAt,\n            f = h.error,\n            p = h.errorUpdatedAt,\n            y = h.fetchStatus,\n            v = h.status,\n            m = !1,\n            b = !1;\n\n        if (e._optimisticResults) {\n          var _i4 = this.hasListeners(),\n              _n8 = !_i4 && Y(t, e),\n              _o2 = _i4 && $(t, s, e, r);\n\n          (_n8 || _o2) && (y = D(t.options.networkMode) ? \"fetching\" : \"paused\", d || (v = \"loading\")), \"isRestoring\" === e._optimisticResults && (y = \"idle\");\n        }\n\n        if (e.keepPreviousData && !h.dataUpdateCount && null != c && c.isSuccess && \"error\" !== v) l = c.data, d = c.dataUpdatedAt, v = c.status, m = !0;else if (e.select && void 0 !== h.data) {\n          if (i && h.data === (null == n ? void 0 : n.data) && e.select === this.selectFn) l = this.selectResult;else try {\n            this.selectFn = e.select, l = e.select(h.data), l = M(null == i ? void 0 : i.data, l, e), this.selectResult = l, this.selectError = null;\n          } catch (t) {\n            this.selectError = t;\n          }\n        } else l = h.data;\n\n        if (void 0 !== e.placeholderData && void 0 === l && \"loading\" === v) {\n          var _t4;\n\n          if (null != i && i.isPlaceholderData && e.placeholderData === (null == o ? void 0 : o.placeholderData)) _t4 = i.data;else if (_t4 = \"function\" == typeof e.placeholderData ? e.placeholderData() : e.placeholderData, e.select && void 0 !== _t4) try {\n            _t4 = e.select(_t4), _t4 = M(null == i ? void 0 : i.data, _t4, e), this.selectError = null;\n          } catch (t) {\n            this.selectError = t;\n          }\n          void 0 !== _t4 && (v = \"success\", l = _t4, b = !0);\n        }\n\n        this.selectError && (f = this.selectError, l = this.selectResult, p = Date.now(), v = \"error\");\n        var g = \"fetching\" === y;\n        return {\n          status: v,\n          fetchStatus: y,\n          isLoading: \"loading\" === v,\n          isSuccess: \"success\" === v,\n          isError: \"error\" === v,\n          data: l,\n          dataUpdatedAt: d,\n          error: f,\n          errorUpdatedAt: p,\n          failureCount: h.fetchFailureCount,\n          errorUpdateCount: h.errorUpdateCount,\n          isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,\n          isFetchedAfterMount: h.dataUpdateCount > u.dataUpdateCount || h.errorUpdateCount > u.errorUpdateCount,\n          isFetching: g,\n          isRefetching: g && \"loading\" !== v,\n          isLoadingError: \"error\" === v && 0 === h.dataUpdatedAt,\n          isPaused: \"paused\" === y,\n          isPlaceholderData: b,\n          isPreviousData: m,\n          isRefetchError: \"error\" === v && 0 !== h.dataUpdatedAt,\n          isStale: tt(t, e),\n          refetch: this.refetch,\n          remove: this.remove\n        };\n      }\n    }, {\n      key: \"updateResult\",\n      value: function updateResult(t) {\n        var _this27 = this;\n\n        var e = this.currentResult,\n            s = this.createResult(this.currentQuery, this.options);\n        if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, R(s, e)) return;\n        this.currentResult = s;\n        var r = {\n          cache: !0\n        };\n        !1 !== (null == t ? void 0 : t.listeners) && function () {\n          if (!e) return !0;\n          var t = _this27.options.notifyOnChangeProps;\n          if (\"all\" === t || !t && !_this27.trackedProps.size) return !0;\n          var s = new Set(null != t ? t : _this27.trackedProps);\n          return _this27.options.useErrorBoundary && s.add(\"error\"), Object.keys(_this27.currentResult).some(function (t) {\n            var r = t;\n            return _this27.currentResult[r] !== e[r] && s.has(r);\n          });\n        }() && (r.listeners = !0), this.notify(_objectSpread(_objectSpread({}, r), t));\n      }\n    }, {\n      key: \"updateQuery\",\n      value: function updateQuery() {\n        var t = this.client.getQueryCache().build(this.client, this.options);\n        if (t === this.currentQuery) return;\n        var e = this.currentQuery;\n        this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == e || e.removeObserver(this), t.addObserver(this));\n      }\n    }, {\n      key: \"onQueryUpdate\",\n      value: function onQueryUpdate(t) {\n        var e = {};\n        \"success\" === t.type ? e.onSuccess = !t.manual : \"error\" !== t.type || I(t.error) || (e.onError = !0), this.updateResult(e), this.hasListeners() && this.updateTimers();\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this28 = this;\n\n        k.batch(function () {\n          var e, s, r, i;\n          if (t.onSuccess) null == (e = (s = _this28.options).onSuccess) || e.call(s, _this28.currentResult.data), null == (r = (i = _this28.options).onSettled) || r.call(i, _this28.currentResult.data, null);else if (t.onError) {\n            var n, o, a, u;\n            null == (n = (o = _this28.options).onError) || n.call(o, _this28.currentResult.error), null == (a = (u = _this28.options).onSettled) || a.call(u, void 0, _this28.currentResult.error);\n          }\n          t.listeners && _this28.listeners.forEach(function (t) {\n            t(_this28.currentResult);\n          }), t.cache && _this28.client.getQueryCache().notify({\n            query: _this28.currentQuery,\n            type: \"observerResultsUpdated\"\n          });\n        });\n      }\n    }]);\n\n    return X;\n  }(n);\n\n  function Y(t, e) {\n    return function (t, e) {\n      return !(!1 === e.enabled || t.state.dataUpdatedAt || \"error\" === t.state.status && !1 === e.retryOnMount);\n    }(t, e) || t.state.dataUpdatedAt > 0 && Z(t, e, e.refetchOnMount);\n  }\n\n  function Z(t, e, s) {\n    if (!1 !== e.enabled) {\n      var r = \"function\" == typeof s ? s(t) : s;\n      return \"always\" === r || !1 !== r && tt(t, e);\n    }\n\n    return !1;\n  }\n\n  function $(t, e, s, r) {\n    return !1 !== s.enabled && (t !== e || !1 === r.enabled) && (!s.suspense || \"error\" !== t.state.status) && tt(t, s);\n  }\n\n  function tt(t, e) {\n    return t.isStaleByTime(e.staleTime);\n  }\n\n  var et = /*#__PURE__*/function (_n9) {\n    _inherits(et, _n9);\n\n    var _super8 = _createSuper(et);\n\n    function et(t, e) {\n      var _this29;\n\n      _classCallCheck(this, et);\n\n      _this29 = _super8.call(this), _this29.client = t, _this29.queries = [], _this29.result = [], _this29.observers = [], _this29.observersMap = {}, e && _this29.setQueries(e);\n      return _this29;\n    }\n\n    _createClass(et, [{\n      key: \"onSubscribe\",\n      value: function onSubscribe() {\n        var _this30 = this;\n\n        1 === this.listeners.length && this.observers.forEach(function (t) {\n          t.subscribe(function (e) {\n            _this30.onUpdate(t, e);\n          });\n        });\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        this.listeners.length || this.destroy();\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.listeners = [], this.observers.forEach(function (t) {\n          t.destroy();\n        });\n      }\n    }, {\n      key: \"setQueries\",\n      value: function setQueries(t, e) {\n        var _this31 = this;\n\n        this.queries = t, k.batch(function () {\n          var t = _this31.observers,\n              s = _this31.findMatchingObservers(_this31.queries);\n\n          s.forEach(function (t) {\n            return t.observer.setOptions(t.defaultedQueryOptions, e);\n          });\n          var r = s.map(function (t) {\n            return t.observer;\n          }),\n              i = Object.fromEntries(r.map(function (t) {\n            return [t.options.queryHash, t];\n          })),\n              n = r.map(function (t) {\n            return t.getCurrentResult();\n          }),\n              o = r.some(function (e, s) {\n            return e !== t[s];\n          });\n          (t.length !== r.length || o) && (_this31.observers = r, _this31.observersMap = i, _this31.result = n, _this31.hasListeners() && (c(t, r).forEach(function (t) {\n            t.destroy();\n          }), c(r, t).forEach(function (t) {\n            t.subscribe(function (e) {\n              _this31.onUpdate(t, e);\n            });\n          }), _this31.notify()));\n        });\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.result;\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        return this.findMatchingObservers(t).map(function (t) {\n          return t.observer.getOptimisticResult(t.defaultedQueryOptions);\n        });\n      }\n    }, {\n      key: \"findMatchingObservers\",\n      value: function findMatchingObservers(t) {\n        var _this32 = this;\n\n        var e = this.observers,\n            s = t.map(function (t) {\n          return _this32.client.defaultQueryOptions(t);\n        }),\n            r = s.flatMap(function (t) {\n          var s = e.find(function (e) {\n            return e.options.queryHash === t.queryHash;\n          });\n          return null != s ? [{\n            defaultedQueryOptions: t,\n            observer: s\n          }] : [];\n        }),\n            i = r.map(function (t) {\n          return t.defaultedQueryOptions.queryHash;\n        }),\n            n = s.filter(function (t) {\n          return !i.includes(t.queryHash);\n        }),\n            o = e.filter(function (t) {\n          return !r.some(function (e) {\n            return e.observer === t;\n          });\n        }),\n            a = function a(t) {\n          var e = _this32.client.defaultQueryOptions(t),\n              s = _this32.observersMap[e.queryHash];\n\n          return null != s ? s : new X(_this32.client, e);\n        },\n            u = n.map(function (t, e) {\n          if (t.keepPreviousData) {\n            var _s5 = o[e];\n            if (void 0 !== _s5) return {\n              defaultedQueryOptions: t,\n              observer: _s5\n            };\n          }\n\n          return {\n            defaultedQueryOptions: t,\n            observer: a(t)\n          };\n        });\n\n        return r.concat(u).sort(function (t, e) {\n          return s.indexOf(t.defaultedQueryOptions) - s.indexOf(e.defaultedQueryOptions);\n        });\n      }\n    }, {\n      key: \"onUpdate\",\n      value: function onUpdate(t, e) {\n        var s = this.observers.indexOf(t);\n        -1 !== s && (this.result = function (t, e, s) {\n          var r = t.slice(0);\n          return r[e] = s, r;\n        }(this.result, s, e), this.notify());\n      }\n    }, {\n      key: \"notify\",\n      value: function notify() {\n        var _this33 = this;\n\n        k.batch(function () {\n          _this33.listeners.forEach(function (t) {\n            t(_this33.result);\n          });\n        });\n      }\n    }]);\n\n    return et;\n  }(n);\n\n  var st = /*#__PURE__*/function (_X) {\n    _inherits(st, _X);\n\n    var _super9 = _createSuper(st);\n\n    function st(t, e) {\n      _classCallCheck(this, st);\n\n      return _super9.call(this, t, e);\n    }\n\n    _createClass(st, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        _get(_getPrototypeOf(st.prototype), \"bindMethods\", this).call(this), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t, e) {\n        _get(_getPrototypeOf(st.prototype), \"setOptions\", this).call(this, _objectSpread(_objectSpread({}, t), {}, {\n          behavior: _()\n        }), e);\n      }\n    }, {\n      key: \"getOptimisticResult\",\n      value: function getOptimisticResult(t) {\n        return t.behavior = _(), _get(_getPrototypeOf(st.prototype), \"getOptimisticResult\", this).call(this, t);\n      }\n    }, {\n      key: \"fetchNextPage\",\n      value: function fetchNextPage() {\n        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref2.pageParam,\n            e = _objectWithoutProperties(_ref2, _excluded2);\n\n        return this.fetch(_objectSpread(_objectSpread({}, e), {}, {\n          meta: {\n            fetchMore: {\n              direction: \"forward\",\n              pageParam: t\n            }\n          }\n        }));\n      }\n    }, {\n      key: \"fetchPreviousPage\",\n      value: function fetchPreviousPage() {\n        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            t = _ref3.pageParam,\n            e = _objectWithoutProperties(_ref3, _excluded3);\n\n        return this.fetch(_objectSpread(_objectSpread({}, e), {}, {\n          meta: {\n            fetchMore: {\n              direction: \"backward\",\n              pageParam: t\n            }\n          }\n        }));\n      }\n    }, {\n      key: \"createResult\",\n      value: function createResult(t, e) {\n        var s, r, i, n, o, a;\n        var u = t.state;\n        return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(st.prototype), \"createResult\", this).call(this, t, e)), {}, {\n          fetchNextPage: this.fetchNextPage,\n          fetchPreviousPage: this.fetchPreviousPage,\n          hasNextPage: J(e, null == (s = u.data) ? void 0 : s.pages),\n          hasPreviousPage: V(e, null == (r = u.data) ? void 0 : r.pages),\n          isFetchingNextPage: \"fetching\" === u.fetchStatus && \"forward\" === (null == (i = u.fetchMeta) || null == (n = i.fetchMore) ? void 0 : n.direction),\n          isFetchingPreviousPage: \"fetching\" === u.fetchStatus && \"backward\" === (null == (o = u.fetchMeta) || null == (a = o.fetchMore) ? void 0 : a.direction)\n        });\n      }\n    }]);\n\n    return st;\n  }(X);\n\n  var rt = /*#__PURE__*/function (_n10) {\n    _inherits(rt, _n10);\n\n    var _super10 = _createSuper(rt);\n\n    function rt(t, e) {\n      var _this34;\n\n      _classCallCheck(this, rt);\n\n      _this34 = _super10.call(this), _this34.client = t, _this34.setOptions(e), _this34.bindMethods(), _this34.updateResult();\n      return _this34;\n    }\n\n    _createClass(rt, [{\n      key: \"bindMethods\",\n      value: function bindMethods() {\n        this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(t) {\n        var e = this.options;\n        this.options = this.client.defaultMutationOptions(t), R(e, this.options) || this.client.getMutationCache().notify({\n          type: \"observerOptionsUpdated\",\n          mutation: this.currentMutation,\n          observer: this\n        });\n      }\n    }, {\n      key: \"onUnsubscribe\",\n      value: function onUnsubscribe() {\n        var t;\n        this.listeners.length || null == (t = this.currentMutation) || t.removeObserver(this);\n      }\n    }, {\n      key: \"onMutationUpdate\",\n      value: function onMutationUpdate(t) {\n        this.updateResult();\n        var e = {\n          listeners: !0\n        };\n        \"success\" === t.type ? e.onSuccess = !0 : \"error\" === t.type && (e.onError = !0), this.notify(e);\n      }\n    }, {\n      key: \"getCurrentResult\",\n      value: function getCurrentResult() {\n        return this.currentResult;\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.currentMutation = void 0, this.updateResult(), this.notify({\n          listeners: !0\n        });\n      }\n    }, {\n      key: \"mutate\",\n      value: function mutate(t, e) {\n        return this.mutateOptions = e, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, _objectSpread(_objectSpread({}, this.options), {}, {\n          variables: void 0 !== t ? t : this.options.variables\n        })), this.currentMutation.addObserver(this), this.currentMutation.execute();\n      }\n    }, {\n      key: \"updateResult\",\n      value: function updateResult() {\n        var t = this.currentMutation ? this.currentMutation.state : {\n          context: void 0,\n          data: void 0,\n          error: null,\n          failureCount: 0,\n          isPaused: !1,\n          status: \"idle\",\n          variables: void 0\n        },\n            e = _objectSpread(_objectSpread({}, t), {}, {\n          isLoading: \"loading\" === t.status,\n          isSuccess: \"success\" === t.status,\n          isError: \"error\" === t.status,\n          isIdle: \"idle\" === t.status,\n          mutate: this.mutate,\n          reset: this.reset\n        });\n\n        this.currentResult = e;\n      }\n    }, {\n      key: \"notify\",\n      value: function notify(t) {\n        var _this35 = this;\n\n        k.batch(function () {\n          var e, s, r, i;\n          if (_this35.mutateOptions) if (t.onSuccess) null == (e = (s = _this35.mutateOptions).onSuccess) || e.call(s, _this35.currentResult.data, _this35.currentResult.variables, _this35.currentResult.context), null == (r = (i = _this35.mutateOptions).onSettled) || r.call(i, _this35.currentResult.data, null, _this35.currentResult.variables, _this35.currentResult.context);else if (t.onError) {\n            var n, o, a, u;\n            null == (n = (o = _this35.mutateOptions).onError) || n.call(o, _this35.currentResult.error, _this35.currentResult.variables, _this35.currentResult.context), null == (a = (u = _this35.mutateOptions).onSettled) || a.call(u, void 0, _this35.currentResult.error, _this35.currentResult.variables, _this35.currentResult.context);\n          }\n          t.listeners && _this35.listeners.forEach(function (t) {\n            t(_this35.currentResult);\n          });\n        });\n      }\n    }]);\n\n    return rt;\n  }(n);\n\n  function it(t) {\n    return t.state.isPaused;\n  }\n\n  function nt(t) {\n    return \"success\" === t.state.status;\n  }\n\n  function ot(t, e, s) {\n    if (\"object\" != typeof e || null === e) return;\n    var r = t.getMutationCache(),\n        i = t.getQueryCache(),\n        n = e.mutations || [],\n        o = e.queries || [];\n    n.forEach(function (e) {\n      var i;\n      r.build(t, _objectSpread(_objectSpread({}, null == s || null == (i = s.defaultOptions) ? void 0 : i.mutations), {}, {\n        mutationKey: e.mutationKey\n      }), e.state);\n    }), o.forEach(function (e) {\n      var r;\n      var n = i.get(e.queryHash);\n      n ? n.state.dataUpdatedAt < e.state.dataUpdatedAt && n.setState(e.state) : i.build(t, _objectSpread(_objectSpread({}, null == s || null == (r = s.defaultOptions) ? void 0 : r.queries), {}, {\n        queryKey: e.queryKey,\n        queryHash: e.queryHash\n      }), e.state);\n    });\n  }\n\n  var at = i.createContext(void 0),\n      ut = i.createContext(!1);\n\n  function ct(t, e) {\n    return t || (e && \"undefined\" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = at), window.ReactQueryClientContext) : at);\n  }\n\n  var ht = function ht() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        t = _ref4.context;\n\n    var e = i.useContext(ct(t, i.useContext(ut)));\n    if (!e) throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    return e;\n  },\n      lt = i.createContext(!1),\n      dt = function dt() {\n    return i.useContext(lt);\n  },\n      ft = lt.Provider;\n\n  function pt() {\n    var t = !1;\n    return {\n      clearReset: function clearReset() {\n        t = !1;\n      },\n      reset: function reset() {\n        t = !0;\n      },\n      isReset: function isReset() {\n        return t;\n      }\n    };\n  }\n\n  var yt = i.createContext(pt()),\n      vt = function vt() {\n    return i.useContext(yt);\n  };\n\n  function mt(t, e) {\n    return \"function\" == typeof t ? t.apply(void 0, _toConsumableArray(e)) : !!t;\n  }\n\n  function bt(t, e) {\n    var r = ht({\n      context: t.context\n    }),\n        n = dt(),\n        o = vt(),\n        a = r.defaultQueryOptions(t);\n    a._optimisticResults = n ? \"isRestoring\" : \"optimistic\", a.onError && (a.onError = k.batchCalls(a.onError)), a.onSuccess && (a.onSuccess = k.batchCalls(a.onSuccess)), a.onSettled && (a.onSettled = k.batchCalls(a.onSettled)), a.suspense && \"number\" != typeof a.staleTime && (a.staleTime = 1e3), (a.suspense || a.useErrorBoundary) && (o.isReset() || (a.retryOnMount = !1));\n\n    var _i$useState = i.useState(function () {\n      return new e(r, a);\n    }),\n        _i$useState2 = _slicedToArray(_i$useState, 1),\n        u = _i$useState2[0],\n        c = u.getOptimisticResult(a);\n\n    if (s.useSyncExternalStore(i.useCallback(function (t) {\n      return n ? function () {} : u.subscribe(k.batchCalls(t));\n    }, [u, n]), function () {\n      return u.getCurrentResult();\n    }, function () {\n      return u.getCurrentResult();\n    }), i.useEffect(function () {\n      o.clearReset();\n    }, [o]), i.useEffect(function () {\n      u.setOptions(a, {\n        listeners: !1\n      });\n    }, [a, u]), a.suspense && c.isLoading && c.isFetching && !n) throw u.fetchOptimistic(a).then(function (_ref5) {\n      var t = _ref5.data;\n      null == a.onSuccess || a.onSuccess(t), null == a.onSettled || a.onSettled(t, null);\n    }).catch(function (t) {\n      o.clearReset(), null == a.onError || a.onError(t), null == a.onSettled || a.onSettled(void 0, t);\n    });\n    if (c.isError && !o.isReset() && !c.isFetching && mt(a.useErrorBoundary, [c.error, u.getCurrentQuery()])) throw c.error;\n    return a.notifyOnChangeProps ? c : u.trackResult(c);\n  }\n\n  function gt(t) {\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var s = ht({\n      context: e.context\n    }),\n        r = i.useRef(e);\n    r.current = e, i.useMemo(function () {\n      t && ot(s, t, r.current);\n    }, [s, t]);\n  }\n\n  function Ot() {}\n\n  t.CancelledError = U, t.Hydrate = function (_ref6) {\n    var t = _ref6.children,\n        e = _ref6.options,\n        s = _ref6.state;\n    return gt(s, e), t;\n  }, t.InfiniteQueryObserver = st, t.IsRestoringProvider = ft, t.MutationCache = G, t.MutationObserver = rt, t.QueriesObserver = et, t.QueryCache = H, t.QueryClient = /*#__PURE__*/function () {\n    function _class3() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, _class3);\n\n      this.queryCache = t.queryCache || new H(), this.mutationCache = t.mutationCache || new G(), this.logger = t.logger || K, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];\n    }\n\n    _createClass(_class3, [{\n      key: \"mount\",\n      value: function mount() {\n        var _this36 = this;\n\n        this.unsubscribeFocus = w.subscribe(function () {\n          w.isFocused() && (_this36.resumePausedMutations(), _this36.queryCache.onFocus());\n        }), this.unsubscribeOnline = F.subscribe(function () {\n          F.isOnline() && (_this36.resumePausedMutations(), _this36.queryCache.onOnline());\n        });\n      }\n    }, {\n      key: \"unmount\",\n      value: function unmount() {\n        var t, e;\n        null == (t = this.unsubscribeFocus) || t.call(this), null == (e = this.unsubscribeOnline) || e.call(this);\n      }\n    }, {\n      key: \"isFetching\",\n      value: function isFetching(t, e) {\n        var _f5 = f(t, e),\n            _f6 = _slicedToArray(_f5, 1),\n            s = _f6[0];\n\n        return s.fetchStatus = \"fetching\", this.queryCache.findAll(s).length;\n      }\n    }, {\n      key: \"isMutating\",\n      value: function isMutating(t) {\n        return this.mutationCache.findAll(_objectSpread(_objectSpread({}, t), {}, {\n          fetching: !0\n        })).length;\n      }\n    }, {\n      key: \"getQueryData\",\n      value: function getQueryData(t, e) {\n        var s;\n        return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state.data;\n      }\n    }, {\n      key: \"getQueriesData\",\n      value: function getQueriesData(t) {\n        return this.getQueryCache().findAll(t).map(function (_ref7) {\n          var t = _ref7.queryKey,\n              e = _ref7.state;\n          return [t, e.data];\n        });\n      }\n    }, {\n      key: \"setQueryData\",\n      value: function setQueryData(t, e, s) {\n        var r = this.queryCache.find(t),\n            i = function (t, e) {\n          return \"function\" == typeof t ? t(e) : t;\n        }(e, null == r ? void 0 : r.state.data);\n\n        if (void 0 === i) return;\n        var n = l(t),\n            o = this.defaultQueryOptions(n);\n        return this.queryCache.build(this, o).setData(i, _objectSpread(_objectSpread({}, s), {}, {\n          manual: !0\n        }));\n      }\n    }, {\n      key: \"setQueriesData\",\n      value: function setQueriesData(t, e, s) {\n        var _this37 = this;\n\n        return k.batch(function () {\n          return _this37.getQueryCache().findAll(t).map(function (_ref8) {\n            var t = _ref8.queryKey;\n            return [t, _this37.setQueryData(t, e, s)];\n          });\n        });\n      }\n    }, {\n      key: \"getQueryState\",\n      value: function getQueryState(t, e) {\n        var s;\n        return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state;\n      }\n    }, {\n      key: \"removeQueries\",\n      value: function removeQueries(t, e) {\n        var _f7 = f(t, e),\n            _f8 = _slicedToArray(_f7, 1),\n            s = _f8[0],\n            r = this.queryCache;\n\n        k.batch(function () {\n          r.findAll(s).forEach(function (t) {\n            r.remove(t);\n          });\n        });\n      }\n    }, {\n      key: \"resetQueries\",\n      value: function resetQueries(t, e, s) {\n        var _this38 = this;\n\n        var _f9 = f(t, e, s),\n            _f10 = _slicedToArray(_f9, 2),\n            r = _f10[0],\n            i = _f10[1],\n            n = this.queryCache,\n            o = _objectSpread({\n          type: \"active\"\n        }, r);\n\n        return k.batch(function () {\n          return n.findAll(r).forEach(function (t) {\n            t.reset();\n          }), _this38.refetchQueries(o, i);\n        });\n      }\n    }, {\n      key: \"cancelQueries\",\n      value: function cancelQueries(t, e, s) {\n        var _this39 = this;\n\n        var _f11 = f(t, e, s),\n            _f12 = _slicedToArray(_f11, 2),\n            r = _f12[0],\n            _f12$ = _f12[1],\n            i = _f12$ === void 0 ? {} : _f12$;\n\n        void 0 === i.revert && (i.revert = !0);\n        var n = k.batch(function () {\n          return _this39.queryCache.findAll(r).map(function (t) {\n            return t.cancel(i);\n          });\n        });\n        return Promise.all(n).then(a).catch(a);\n      }\n    }, {\n      key: \"invalidateQueries\",\n      value: function invalidateQueries(t, e, s) {\n        var _this40 = this;\n\n        var _f13 = f(t, e, s),\n            _f14 = _slicedToArray(_f13, 2),\n            r = _f14[0],\n            i = _f14[1];\n\n        return k.batch(function () {\n          var t, e;\n          if (_this40.queryCache.findAll(r).forEach(function (t) {\n            t.invalidate();\n          }), \"none\" === r.refetchType) return Promise.resolve();\n\n          var s = _objectSpread(_objectSpread({}, r), {}, {\n            type: null != (t = null != (e = r.refetchType) ? e : r.type) ? t : \"active\"\n          });\n\n          return _this40.refetchQueries(s, i);\n        });\n      }\n    }, {\n      key: \"refetchQueries\",\n      value: function refetchQueries(t, e, s) {\n        var _this41 = this;\n\n        var _f15 = f(t, e, s),\n            _f16 = _slicedToArray(_f15, 2),\n            r = _f16[0],\n            i = _f16[1],\n            n = k.batch(function () {\n          return _this41.queryCache.findAll(r).filter(function (t) {\n            return !t.isDisabled();\n          }).map(function (t) {\n            var e;\n            return t.fetch(void 0, _objectSpread(_objectSpread({}, i), {}, {\n              cancelRefetch: null == (e = null == i ? void 0 : i.cancelRefetch) || e,\n              meta: {\n                refetchPage: r.refetchPage\n              }\n            }));\n          });\n        });\n\n        var o = Promise.all(n).then(a);\n        return null != i && i.throwOnError || (o = o.catch(a)), o;\n      }\n    }, {\n      key: \"fetchQuery\",\n      value: function fetchQuery(t, e, s) {\n        var r = l(t, e, s),\n            i = this.defaultQueryOptions(r);\n        void 0 === i.retry && (i.retry = !1);\n        var n = this.queryCache.build(this, i);\n        return n.isStaleByTime(i.staleTime) ? n.fetch(i) : Promise.resolve(n.state.data);\n      }\n    }, {\n      key: \"prefetchQuery\",\n      value: function prefetchQuery(t, e, s) {\n        return this.fetchQuery(t, e, s).then(a).catch(a);\n      }\n    }, {\n      key: \"fetchInfiniteQuery\",\n      value: function fetchInfiniteQuery(t, e, s) {\n        var r = l(t, e, s);\n        return r.behavior = _(), this.fetchQuery(r);\n      }\n    }, {\n      key: \"prefetchInfiniteQuery\",\n      value: function prefetchInfiniteQuery(t, e, s) {\n        return this.fetchInfiniteQuery(t, e, s).then(a).catch(a);\n      }\n    }, {\n      key: \"resumePausedMutations\",\n      value: function resumePausedMutations() {\n        return this.mutationCache.resumePausedMutations();\n      }\n    }, {\n      key: \"getQueryCache\",\n      value: function getQueryCache() {\n        return this.queryCache;\n      }\n    }, {\n      key: \"getMutationCache\",\n      value: function getMutationCache() {\n        return this.mutationCache;\n      }\n    }, {\n      key: \"getLogger\",\n      value: function getLogger() {\n        return this.logger;\n      }\n    }, {\n      key: \"getDefaultOptions\",\n      value: function getDefaultOptions() {\n        return this.defaultOptions;\n      }\n    }, {\n      key: \"setDefaultOptions\",\n      value: function setDefaultOptions(t) {\n        this.defaultOptions = t;\n      }\n    }, {\n      key: \"setQueryDefaults\",\n      value: function setQueryDefaults(t, e) {\n        var s = this.queryDefaults.find(function (e) {\n          return b(t) === b(e.queryKey);\n        });\n        s ? s.defaultOptions = e : this.queryDefaults.push({\n          queryKey: t,\n          defaultOptions: e\n        });\n      }\n    }, {\n      key: \"getQueryDefaults\",\n      value: function getQueryDefaults(t) {\n        if (!t) return;\n        var e = this.queryDefaults.find(function (e) {\n          return g(t, e.queryKey);\n        });\n        return null == e ? void 0 : e.defaultOptions;\n      }\n    }, {\n      key: \"setMutationDefaults\",\n      value: function setMutationDefaults(t, e) {\n        var s = this.mutationDefaults.find(function (e) {\n          return b(t) === b(e.mutationKey);\n        });\n        s ? s.defaultOptions = e : this.mutationDefaults.push({\n          mutationKey: t,\n          defaultOptions: e\n        });\n      }\n    }, {\n      key: \"getMutationDefaults\",\n      value: function getMutationDefaults(t) {\n        if (!t) return;\n        var e = this.mutationDefaults.find(function (e) {\n          return g(t, e.mutationKey);\n        });\n        return null == e ? void 0 : e.defaultOptions;\n      }\n    }, {\n      key: \"defaultQueryOptions\",\n      value: function defaultQueryOptions(t) {\n        if (null != t && t._defaulted) return t;\n\n        var e = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.queries), this.getQueryDefaults(null == t ? void 0 : t.queryKey)), t), {}, {\n          _defaulted: !0\n        });\n\n        return !e.queryHash && e.queryKey && (e.queryHash = m(e.queryKey, e)), void 0 === e.refetchOnReconnect && (e.refetchOnReconnect = \"always\" !== e.networkMode), void 0 === e.useErrorBoundary && (e.useErrorBoundary = !!e.suspense), e;\n      }\n    }, {\n      key: \"defaultMutationOptions\",\n      value: function defaultMutationOptions(t) {\n        return null != t && t._defaulted ? t : _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.mutations), this.getMutationDefaults(null == t ? void 0 : t.mutationKey)), t), {}, {\n          _defaulted: !0\n        });\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.queryCache.clear(), this.mutationCache.clear();\n      }\n    }]);\n\n    return _class3;\n  }(), t.QueryClientProvider = function (_ref9) {\n    var t = _ref9.client,\n        e = _ref9.children,\n        s = _ref9.context,\n        _ref9$contextSharing = _ref9.contextSharing,\n        r = _ref9$contextSharing === void 0 ? !1 : _ref9$contextSharing;\n    i.useEffect(function () {\n      return t.mount(), function () {\n        t.unmount();\n      };\n    }, [t]);\n    var n = ct(s, r);\n    return i.createElement(ut.Provider, {\n      value: !s && r\n    }, i.createElement(n.Provider, {\n      value: t\n    }, e));\n  }, t.QueryErrorResetBoundary = function (_ref10) {\n    var t = _ref10.children;\n\n    var _i$useState3 = i.useState(function () {\n      return pt();\n    }),\n        _i$useState4 = _slicedToArray(_i$useState3, 1),\n        e = _i$useState4[0];\n\n    return i.createElement(yt.Provider, {\n      value: e\n    }, \"function\" == typeof t ? t(e) : t);\n  }, t.QueryObserver = X, t.defaultContext = at, t.dehydrate = function (t) {\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var s = [],\n        r = [];\n\n    if (!1 !== e.dehydrateMutations) {\n      var _r3 = e.shouldDehydrateMutation || it;\n\n      t.getMutationCache().getAll().forEach(function (t) {\n        _r3(t) && s.push(function (t) {\n          return {\n            mutationKey: t.options.mutationKey,\n            state: t.state\n          };\n        }(t));\n      });\n    }\n\n    if (!1 !== e.dehydrateQueries) {\n      var _s6 = e.shouldDehydrateQuery || nt;\n\n      t.getQueryCache().getAll().forEach(function (t) {\n        _s6(t) && r.push(function (t) {\n          return {\n            state: t.state,\n            queryKey: t.queryKey,\n            queryHash: t.queryHash\n          };\n        }(t));\n      });\n    }\n\n    return {\n      mutations: s,\n      queries: r\n    };\n  }, t.focusManager = w, t.hashQueryKey = b, t.hydrate = ot, t.isCancelledError = I, t.isError = function (t) {\n    return t instanceof Error;\n  }, t.notifyManager = k, t.onlineManager = F, t.parseFilterArgs = f, t.parseMutationArgs = d, t.parseMutationFilterArgs = p, t.parseQueryArgs = l, t.useHydrate = gt, t.useInfiniteQuery = function (t, e, s) {\n    return bt(l(t, e, s), st);\n  }, t.useIsFetching = function (t, e, r) {\n    var _f17 = f(t, e, r),\n        _f18 = _slicedToArray(_f17, 2),\n        n = _f18[0],\n        _f18$ = _f18[1],\n        o = _f18$ === void 0 ? {} : _f18$,\n        a = ht({\n      context: o.context\n    }),\n        u = a.getQueryCache();\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return u.subscribe(k.batchCalls(t));\n    }, [u]), function () {\n      return a.isFetching(n);\n    }, function () {\n      return a.isFetching(n);\n    });\n  }, t.useIsMutating = function (t, e, r) {\n    var _p = p(t, e, r),\n        _p2 = _slicedToArray(_p, 2),\n        n = _p2[0],\n        _p2$ = _p2[1],\n        o = _p2$ === void 0 ? {} : _p2$,\n        a = ht({\n      context: o.context\n    }),\n        u = a.getMutationCache();\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return u.subscribe(k.batchCalls(t));\n    }, [u]), function () {\n      return a.isMutating(n);\n    }, function () {\n      return a.isMutating(n);\n    });\n  }, t.useIsRestoring = dt, t.useMutation = function (t, e, r) {\n    var n = d(t, e, r),\n        o = ht({\n      context: n.context\n    }),\n        _i$useState5 = i.useState(function () {\n      return new rt(o, n);\n    }),\n        _i$useState6 = _slicedToArray(_i$useState5, 1),\n        a = _i$useState6[0];\n\n    i.useEffect(function () {\n      a.setOptions(n);\n    }, [a, n]);\n    var u = s.useSyncExternalStore(i.useCallback(function (t) {\n      return a.subscribe(k.batchCalls(t));\n    }, [a]), function () {\n      return a.getCurrentResult();\n    }, function () {\n      return a.getCurrentResult();\n    }),\n        c = i.useCallback(function (t, e) {\n      a.mutate(t, e).catch(Ot);\n    }, [a]);\n    if (u.error && mt(a.options.useErrorBoundary, [u.error])) throw u.error;\n    return _objectSpread(_objectSpread({}, u), {}, {\n      mutate: c,\n      mutateAsync: u.mutate\n    });\n  }, t.useQueries = function (_ref11) {\n    var t = _ref11.queries,\n        e = _ref11.context;\n\n    var r = ht({\n      context: e\n    }),\n        n = dt(),\n        o = i.useMemo(function () {\n      return t.map(function (t) {\n        var e = r.defaultQueryOptions(t);\n        return e._optimisticResults = n ? \"isRestoring\" : \"optimistic\", e;\n      });\n    }, [t, r, n]),\n        _i$useState7 = i.useState(function () {\n      return new et(r, o);\n    }),\n        _i$useState8 = _slicedToArray(_i$useState7, 1),\n        a = _i$useState8[0],\n        u = a.getOptimisticResult(o);\n\n    return s.useSyncExternalStore(i.useCallback(function (t) {\n      return n ? function () {} : a.subscribe(k.batchCalls(t));\n    }, [a, n]), function () {\n      return a.getCurrentResult();\n    }, function () {\n      return a.getCurrentResult();\n    }), i.useEffect(function () {\n      a.setQueries(o, {\n        listeners: !1\n      });\n    }, [o, a]), u;\n  }, t.useQuery = function (t, e, s) {\n    return bt(l(t, e, s), X);\n  }, t.useQueryClient = ht, t.useQueryErrorResetBoundary = vt, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"mappings":"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","names":["Subscribable","constructor","this","listeners","subscribe","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","onlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","queue","transactions","notifyFn","batchNotifyFn","schedule","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchMeta","isInvalidated","getDefaultState$1","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","Error","action","_action$meta","_action$dataUpdatedAt","notifyManager","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","getDefaultState","execute","async","executeMutation","_this$options$retry","variables","restored","_this$mutationCache$c","_this$mutationCache$c2","onMutate","_this$options$onMutat","_this$options","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isFetching","isLoading","isError","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","size","includedProps","useErrorBoundary","typedKey","has","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","getMutationCache","currentMutation","_this$currentMutation","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","hydrate","dehydratedState","queryCache","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","defaultContext","React","createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useContext","IsRestoringContext","useIsRestoring","IsRestoringProvider","Provider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","_useErrorBoundary","params","useBaseQuery","Observer","isRestoring","errorResetBoundary","useState","useSyncExternalStore","useCallback","onStoreChange","useEffect","useHydrate","optionsRef","useRef","current","useMemo","children","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","parsedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","Context","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","mutateAsync","defaultedQueries"],"sources":["/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/query-core/build/esm/index.js","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/isRestoring.tsx","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/utils.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useBaseQuery.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/Hydrate.tsx","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useMutation.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useInfiniteQuery.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useIsFetching.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useIsMutating.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useQueries.ts","/Users/kimhaneui/Documents/리액트 프로젝트/shop/node_modules/@tanstack/react-query/src/useQuery.ts"],"sourcesContent":["/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\n\nimport { QueryClient } from '@tanstack/query-core'\nimport { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import * as React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n  MutationFunction,\n  MutationKey,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import {\n  QueryObserver,\n  InfiniteQueryObserver,\n  QueryFunction,\n  QueryKey,\n  parseQueryArgs,\n} from '@tanstack/query-core'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import * as React from 'react'\nimport {\n  QueryKey,\n  notifyManager,\n  parseFilterArgs,\n  QueryFilters,\n} from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  MutationKey,\n  MutationFilters,\n  parseMutationFilterArgs,\n} from '@tanstack/query-core'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  QueryKey,\n  QueryFunction,\n  notifyManager,\n  QueriesObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n","import {\n  parseQueryArgs,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport { DefinedUseQueryResult, UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"]},"metadata":{},"sourceType":"script"}